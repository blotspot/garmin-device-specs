<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Data Query</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* Prevent the body itself from scrolling */
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        line-height: 1.6;
        color: #333;
      }
      .page-container {
        display: flex;
        flex-direction: column;
        height: 100vh; /* Fill the entire viewport height */
        max-width: 95%;
        margin: 0 auto;
        padding: 20px;
        box-sizing: border-box;
      }
      h1 {
        text-align: center;
        flex-shrink: 0;
      }
      .search-container {
        margin-bottom: 20px;
        flex-shrink: 0;
      }
      .search-container input {
        width: 100%;
        box-sizing: border-box;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 16px;
      }
      .info-box {
        background-color: #eef;
        border-left: 4px solid #55f;
        padding: 10px 15px;
        margin: 10px 0;
        flex-shrink: 0;
        font-size: 0.9em;
      }
      .table-container {
        flex-grow: 1;
        overflow-y: auto;
        overflow-x: auto;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      td {
        padding: 12px 15px;
        border: 1px solid #ddd;
      }
      th {
        padding: 12px 15px;
        text-align: left;
        white-space: nowrap;
        position: sticky;
        top: 0;
        background-color: #f4f4f4;
        border-bottom: 2px solid #ccc;
        z-index: 1;
      }
      th.sortable {
        cursor: pointer;
      }
      th.sortable:hover {
        background-color: #e9e9e9;
      }
      th.sortable::after {
        content: "";
        position: absolute;
        right: 10px;
        top: 50%;
        margin-top: -8px;
        border: 5px solid transparent;
        opacity: 0.3;
      }
      th.sortable.sort-asc::after {
        border-bottom-color: #333;
        opacity: 1;
      }
      th.sortable.sort-desc::after {
        border-top-color: #333;
        opacity: 1;
      }
      tbody tr:nth-of-type(even) {
        background-color: #f9f9f9;
      }
      .status {
        text-align: left;
        color: #888;
        padding: 10px 15px;
        margin: 10px 0;
        font-size: 0.9em;
        border: 0;
      }
      .status:has(.error) {
        color: #333;
        background-color: #fee;
      }
    </style>
  </head>
  <body>
    <div class="page-container">
      <h1>Device Data Query</h1>
      <p>The data was last updated on <span id="last-updated">...</span>.</p>

      <div class="search-container">
        <input type="text" id="search-input" placeholder="Search for text or use an advanced query..." />
      </div>

      <div class="info-box">
        <p><b>Query Guide:</b></p>
        <ul>
          <li><b>Simple Search:</b> Type any text to search across all fields (e.g., <code>approachs70</code>).</li>
          <li>
            <b>Advanced Query:</b> Use the format <code>Attribute Operator Value</code> (e.g., <code>WatchAppMemory >= 262144</code> or <code>APILevel > 3</code>). Supported operators are
            <code>>=</code>, <code><=</code>, <code>></code>, <code><</code>, <code>==</code>, <code>!=</code>.
          </li>
          <li><b>Sorting:</b> Click on any column header to sort the table.</li>
        </ul>
      </div>

      <div class="table-container">
        <table id="results-table">
          <thead>
            <tr id="table-headers"></tr>
          </thead>
          <tbody id="table-body">
            <tr id="initial-status">
              <td class="status"><div>Loading data...</div></td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- CONFIGURATION ---
        const JSON_URL = "garmin_devices.json";
        const COLUMNS = [
          "Date",
          "Name",
          "Id",
          "ScreenShape",
          "ScreenSize",
          "APILevel",
          "AudioContentProviderMemory",
          "BackgroundMemory",
          "DataFieldMemory",
          "GlanceMemory",
          "WatchAppMemory",
          "WatchFaceMemory",
          "WidgetMemory",
          "Touch",
          "Buttons",
        ];

        // --- DOM ELEMENTS ---
        const searchInput = document.getElementById("search-input");
        const tableHeaders = document.getElementById("table-headers");
        const tableBody = document.getElementById("table-body");
        const lastUpdatedSpan = document.getElementById("last-updated");
        const initialStatus = document.getElementById("initial-status");

        let allData = [];
        let visibleData = [];

        // --- INITIALIZATION ---
        function initialize() {
          renderTableHeaders();
          fetchData();
        }

        function renderTableHeaders() {
          tableHeaders.innerHTML = "";
          initialStatus.querySelector("td").colSpan = COLUMNS.length;

          COLUMNS.forEach((col, index) => {
            const th = document.createElement("th");
            th.textContent = col;
            th.className = "sortable"; // Add class to make it look clickable
            th.dataset.columnIndex = index; // Store column index
            th.addEventListener("click", () => sortTableByColumn(th));
            tableHeaders.appendChild(th);
          });
        }

        function fetchData() {
          fetch(JSON_URL)
            .then((response) => {
              if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
              const lastModified = response.headers.get("last-modified");
              if (lastModified) lastUpdatedSpan.textContent = new Date(lastModified).toUTCString();
              return response.json();
            })
            .then((data) => {
              allData = Array.isArray(data) ? data : [];
              allData = allData.filter((item) => item && item.Active);
              renderTableRows(allData);
            })
            .catch((error) => {
              console.error("Error fetching data:", error);
              renderStatus("Could not load data. Please check the console for details.", true);
            });
        }

        // --- EVENT HANDLING ---
        searchInput.addEventListener("input", () => {
          const query = searchInput.value.trim();
          filterAndRender(query);
        });

        // --- CORE LOGIC ---
        function filterAndRender(query) {
          let filteredData = [];
          // Regex to parse "Attribute Operator Value" queries, e.g., "Memory >= 256000"
          const advancedQueryRegex = /^(\w+)\s*([><!=]=?)\s*"?\s*([-_\d\w\s\.]+)?\s*"?\s*$/;
          const match = query.match(advancedQueryRegex);

          try {
            if (match) {
              // Advanced JQ-like query
              const [, attribute, operator, value] = match;

              filteredData = allData.filter((item) => {
                const itemValue = item[attribute];
                if (itemValue === undefined) return false;
                var parsedValue = value;
                if (typeof itemValue === "number") {
                  parsedValue = parseFloat(value);
                  if (isNaN(value)) {
                    return false;
                  }
                } else if (typeof itemValue === "boolean") {
                  parsedValue = ["true", "1"].includes(value?.toLowerCase());
                }

                switch (operator) {
                  case ">":
                    return itemValue > parsedValue;
                  case ">=":
                    return itemValue >= parsedValue;
                  case "<":
                    return itemValue < parsedValue;
                  case "<=":
                    return itemValue <= parsedValue;
                  case "=":
                  case "==":
                    return itemValue == parsedValue;
                  case "!=":
                    return itemValue != parsedValue;
                  default:
                    return false;
                }
              });
            } else if (query) {
              // Simple text search
              const lowerCaseQuery = query.toLowerCase();
              filteredData = allData.filter((item) => {
                return Object.values(item).some((val) => String(val).toLowerCase().includes(lowerCaseQuery));
              });
            } else {
              // No query, show all data
              filteredData = allData;
            }
            renderTableRows(filteredData);
          } catch (error) {
            console.error("Error fetching data:", error);
            renderStatus("Error processing query. Please check the console for details.", true);
          }
        }

        function renderStatus(message, error = false) {
          tableBody.innerHTML = "";
          visibleData = [];
          const row = tableBody.insertRow();
          const cell = row.insertCell();
          cell.colSpan = COLUMNS.length;
          cell.className = "status";
          cell.innerHTML = `<p class="${error ? "error" : ""}">${message}</p>`;
        }

        function renderTableRows(data) {
          tableBody.innerHTML = "";
          visibleData = data;

          if (data.length === 0 && searchInput.value) {
            renderStatus("No results found for your query.");
          } else if (data.length === 0) {
            renderStatus("No data available.");
          } else {
            data.forEach((item) => {
              const row = tableBody.insertRow();
              COLUMNS.forEach((col) => {
                const cell = row.insertCell();
                if (col == "Touch" || col == "Active") {
                  cell.textContent = item[col] ? "Yes" : "No";
                } else if (col == "Date") {
                  cell.textContent = new Date(item[col]).toLocaleDateString();
                } else {
                  cell.textContent = item[col] ?? "";
                }
              });
            });
          }
        }

        // --- SORTING FUNCTION ---
        function sortTableByColumn(headerElement) {
          const columnIndex = parseInt(headerElement.dataset.columnIndex, 10);
          const currentDirection = headerElement.dataset.sortDirection || "desc";
          const newDirection = currentDirection === "desc" ? "asc" : "desc";
          headerElement.dataset.sortDirection = newDirection;

          // Remove sorting indicators from other columns
          tableHeaders.querySelectorAll("th").forEach((th) => {
            th.classList.remove("sort-asc", "sort-desc");
          });

          // Add sorting indicator to the current column
          headerElement.classList.add(newDirection === "asc" ? "sort-asc" : "sort-desc");

          visibleData.sort((a, b) => {
            const column = COLUMNS[columnIndex];
            const valA = a[column];
            const valB = b[column];

            let comparison = 0;
            if (column.endsWith("Memory")) {
              comparison = (valA ?? 0) - (valB ?? 0);
            } else {
              comparison = String(valA).localeCompare(String(valB), undefined, { sensitivity: "base" });
            }

            return newDirection === "asc" ? comparison : -comparison;
          });
          renderTableRows(visibleData);
        }

        initialize();
      });
    </script>
  </body>
</html>
