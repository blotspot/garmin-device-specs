<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Data Query</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* Prevent the body itself from scrolling */
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        font-size: 0.95rem;
      }
      .page-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        max-width: 95%;
        margin: 0 auto;
        padding: 20px;
        box-sizing: border-box;
      }
      h1 {
        text-align: center;
        font-size: 1.2em;
      }
      .search-container input {
        width: 100%;
        box-sizing: border-box;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 16px;
      }
      .info-box {
        background-color: #eef;
        border-left: 4px solid #55f;
        padding: 10px 15px;
        margin: 10px 0;
        font-size: 0.9em;
      }

      #row-counter {
        text-align: center;
        padding-bottom: 5px;
        font-size: 0.9em;
        color: #555;
      }
      .table-container {
        flex-grow: 1;
        overflow-y: auto;
        overflow-x: auto;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      td {
        padding: 12px 15px;
        border: 1px solid #ddd;
      }
      th {
        padding: 12px 15px;
        text-align: left;
        white-space: nowrap;
        position: sticky;
        top: 0;
        background-color: #f4f4f4;
        border-bottom: 2px solid #ccc;
        z-index: 1;
      }
      th.sortable {
        cursor: pointer;
      }
      th.sortable:hover {
        background-color: #e9e9e9;
      }
      th.sortable::after {
        content: "";
        position: absolute;
        right: 10px;
        top: 50%;
        margin-top: -8px;
        border: 5px solid transparent;
        opacity: 0.3;
      }
      th.sortable.sort-asc::after {
        border-bottom-color: #333;
        opacity: 1;
      }
      th.sortable.sort-desc::after {
        border-top-color: #333;
        opacity: 1;
      }
      tbody tr:nth-of-type(even) {
        background-color: #f9f9f9;
      }
      .status {
        text-align: left;
        color: #888;
        padding: 10px 15px;
        margin: 10px 0;
        font-size: 0.9em;
        border: 0;
      }
      .status:has(.error) {
        color: #333;
        background-color: #fee;
      }
    </style>
  </head>
  <body>
    <div class="page-container">
      <h1>Garmin Device Data Query</h1>
      <p>The data was last updated on <span id="last-updated">...</span>.</p>

      <div class="search-container">
        <input type="text" id="search-input" placeholder="Search for text or use an advanced query..." />
      </div>

      <div class="info-box">
        <ul>
          <li><b>Simple Search:</b> Type any text to search across all fields (e.g., <code>round</code>).</li>
          <li>
            <b>Advanced Query:</b> Use the format <code>Attribute Operator Value</code> (e.g., <code>WatchAppMemory >= 262144</code> or <code>APILevel > 3</code>). Supported operators are
            <code>>=</code>, <code><=</code>, <code>></code>, <code><</code>, <code>==</code>, <code>!=</code>.
          </li>
        </ul>
      </div>

      <div id="row-counter"></div>

      <div class="table-container">
        <table id="results-table">
          <thead>
            <tr id="table-headers"></tr>
          </thead>
          <tbody id="table-body">
            <tr id="initial-status">
              <td class="status"><div>Loading data...</div></td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- CONFIGURATION ---
        const JSON_URL = "garmin_devices.json";
        const COLUMNS = [
          "Date",
          "Name",
          "Id",
          "ScreenShape",
          "ScreenSize",
          "APILevel",
          "AudioContentProviderMemory",
          "BackgroundMemory",
          "DataFieldMemory",
          "GlanceMemory",
          "WatchAppMemory",
          "WatchFaceMemory",
          "WidgetMemory",
          "Touch",
          "Buttons",
        ];

        // --- DOM ELEMENTS ---
        const searchInput = document.getElementById("search-input");
        const tableHeaders = document.getElementById("table-headers");
        const tableBody = document.getElementById("table-body");
        const lastUpdatedSpan = document.getElementById("last-updated");
        const rowCounter = document.getElementById("row-counter");

        let allData = [];
        let visibleData = [];
        let sortingColumn = null;
        let currentDirection = null;

        // --- INITIALIZATION ---
        function initialize() {
          renderTableHeaders();
          fetchData();
        }

        function renderTableHeaders() {
          tableHeaders.innerHTML = "";
          document.getElementById("initial-status").querySelector("td").colSpan = COLUMNS.length;

          COLUMNS.forEach((col, index) => {
            const th = document.createElement("th");
            th.textContent = col;
            th.className = "sortable"; // Add class to make it look clickable
            th.dataset.columnIndex = index; // Store column index
            th.addEventListener("click", () => {
              toggleSortDirection(th);
              sortTableByColumn(th);
              renderTableRows(visibleData);
            });
            tableHeaders.appendChild(th);
          });
        }

        function fetchData() {
          fetch(JSON_URL)
            .then((response) => {
              if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
              const lastModified = new Date(response.headers.get("last-modified"));
              if (lastModified) {
                lastUpdatedSpan.textContent = `${lastModified.toLocaleDateString()} at ${lastModified.toLocaleTimeString()}`;
              } else {
                lastUpdatedSpan.display = "none";
              }
              return response.json();
            })
            .then((data) => {
              allData = Array.isArray(data) ? data : [];
              allData = allData.filter((item) => item && item.Active);
              visibleData = [...allData]; // Start with all data visible
              const query = searchInput.value.trim();
              if (query) {
                filterData(query);
              }
              renderTableRows(visibleData);
            })
            .catch((error) => {
              console.error("Error fetching data:", error);
              renderStatus("Could not load data. Please check the console for details.", true);
            });
        }

        // --- EVENT HANDLING ---
        searchInput.addEventListener("input", () => {
          const query = searchInput.value.trim();
          filterData(query);
          sortTableByColumn(sortingColumn || tableHeaders.firstElementChild);
          renderTableRows(visibleData);
        });

        // --- FILTER LOGIC ---
        function evaluateCondition(item, condition) {
          const [attribute, operator, value] = condition;

          if (value === undefined) {
            return true;
          } else if (attribute === null && operator === null) {
            // If no attribute is specified, check if the value is in any field
            return Object.values(item).some((val) => String(val).toLowerCase().includes(value.toLowerCase()));
          } else {
            const itemValue = item[attribute];
            if (itemValue === undefined) {
              return false;
            }
            var parsedValue = value;
            if (attribute.endsWith("Memory")) {
              parsedValue = parseInt(value);
              if (isNaN(value)) {
                return false;
              }
            } else if (typeof itemValue === "boolean") {
              parsedValue = ["true", "1"].includes(value?.toLowerCase());
            }

            switch (operator) {
              case ">":
                return itemValue > parsedValue;
              case ">=":
                return itemValue >= parsedValue;
              case "<":
                return itemValue < parsedValue;
              case "<=":
                return itemValue <= parsedValue;
              case "=":
              case "==":
                return itemValue == parsedValue;
              case "!=":
                return itemValue != parsedValue;
              default:
                return false;
            }
          }
        }

        function filterData(query) {
          const advancedQueryRegex = /^(\w+)\s*([><!=]=?)\s*"?\s*([-_\d\w\s\.]+)?\s*"?\s*$/;
          const separatorRegex = /\s+(?:AND|&&)\s+/i;
          const match = query.match(advancedQueryRegex);

          try {
            const parts = query.split(separatorRegex);
            const conditions = parts.map((part) => {
              const trimmedPart = part.trim();
              const match = trimmedPart.match(advancedQueryRegex);
              if (!match) {
                return [null, null, trimmedPart];
              }
              const [, attribute, operator, value] = match;
              return [attribute, operator, value];
            });

            // Filter data: item must satisfy EVERY condition.
            visibleData = allData.filter((item) => {
              return conditions.every((cond) => evaluateCondition(item, cond));
            });

            sortTableByColumn(sortingColumn || tableHeaders.firstElementChild);
          } catch (error) {
            console.error("Error fetching data:", error);
            renderStatus("Error processing query. Please check the console for details.", true);
          }
        }

        function renderStatus(message, error = false) {
          tableBody.innerHTML = "";
          visibleData = [];
          const row = tableBody.insertRow();
          const cell = row.insertCell();
          cell.colSpan = COLUMNS.length;
          cell.className = "status";
          cell.innerHTML = `<p class="${error ? "error" : ""}">${message}</p>`;
        }

        function renderTableRows(data) {
          tableBody.innerHTML = "";
          visibleData = data;

          if (data.length === 0 && searchInput.value) {
            rowCounter.display = "none";
            renderStatus("No results found for your query.");
          } else if (data.length === 0) {
            rowCounter.display = "none";
            renderStatus("No data available.");
          } else {
            rowCounter.display = "block";
            if (data.length < allData.length) {
              rowCounter.textContent = `Showing ${data.length} of ${allData.length} entries`;
            } else {
              rowCounter.textContent = `Showing ${data.length} entries`;
            }
            data.forEach((item) => {
              const row = tableBody.insertRow();
              COLUMNS.forEach((col) => {
                const cell = row.insertCell();
                if (col == "Touch" || col == "Active") {
                  cell.textContent = item[col] ? "Yes" : "No";
                } else if (col == "Date") {
                  cell.textContent = new Date(item[col]).toLocaleDateString();
                } else if (col.endsWith("Memory")) {
                  const memoryValue = parseInt(item[col], 10);
                  if (!isNaN(memoryValue)) {
                    if (memoryValue >= 1024 * 1024) {
                      cell.textContent = (memoryValue / (1024 * 1024)).toFixed(2).toLocaleString() + " MB";
                    } else {
                      cell.textContent = (memoryValue / 1024).toFixed(0).toLocaleString() + " KB";
                    }
                  }
                } else {
                  cell.textContent = item[col] ?? "";
                }
              });
            });
          }
        }

        // --- SORTING FUNCTION ---
        function sortTableByColumn(headerElement) {
          const columnIndex = parseInt(headerElement.dataset.columnIndex, 10);

          visibleData.sort((a, b) => {
            const column = COLUMNS[columnIndex];
            const valA = a[column];
            const valB = b[column];

            let comparison = 0;
            if (column.endsWith("Memory")) {
              comparison = (valA ?? 0) - (valB ?? 0);
            } else {
              comparison = String(valA).localeCompare(String(valB), undefined, { sensitivity: "base" });
            }

            return currentDirection === "asc" ? comparison : -comparison;
          });
        }

        function toggleSortDirection(headerElement) {
          // set new sorting column and direction
          if (sortingColumn === headerElement) {
            currentDirection = currentDirection === "asc" ? "desc" : "asc";
          } else {
            sortingColumn = headerElement;
            currentDirection = headerElement.dataset.sortDirection || "asc";
          }
          headerElement.dataset.sortDirection = currentDirection;

          // Remove sorting indicators from other columns
          tableHeaders.querySelectorAll("th").forEach((th) => {
            th.classList.remove("sort-asc", "sort-desc");
          });

          // Add sorting indicator to the current column
          headerElement.classList.add(currentDirection === "asc" ? "sort-asc" : "sort-desc");
        }

        initialize();
      });
    </script>
  </body>
</html>
