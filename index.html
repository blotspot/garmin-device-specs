<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Data Query</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 95%;
        margin: 0 auto;
        padding: 20px;
      }
      h1 {
        text-align: center;
      }
      .search-container {
        margin-bottom: 20px;
      }
      .search-container input {
        width: 100%;
        box-sizing: border-box;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 16px;
      }
      .info-box {
        background-color: #eef;
        border-left: 4px solid #55f;
        padding: 10px 15px;
        margin: 15px 0;
        font-size: 0.9em;
      }
      .table-container {
        overflow-x: auto;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
      }
      th,
      td {
        padding: 12px 15px;
        border: 1px solid #ddd;
        text-align: left;
      }
      th {
        background-color: #f4f4f4;
      }
      th.sortable {
        cursor: pointer;
        position: relative;
      }
      th.sortable:hover {
        background-color: #e9e9e9;
      }
      /* Arrows for sort direction */
      th.sortable::after {
        content: "";
        position: absolute;
        right: 10px;
        top: 50%;
        margin-top: -8px;
        border: 5px solid transparent;
        opacity: 0.3;
      }
      th.sortable.sort-asc::after {
        border-bottom-color: #333;
        opacity: 1;
      }
      th.sortable.sort-desc::after {
        border-top-color: #333;
        opacity: 1;
      }
      tbody tr:nth-of-type(even) {
        background-color: #f9f9f9;
      }
      .status {
        text-align: center;
        color: #888;
        font-size: 18px;
        padding: 20px;
      }
    </style>
  </head>
  <body>
    <h1>Device Data Query</h1>
    <p>The data was last updated on <span id="last-updated">...</span>.</p>

    <div class="search-container">
      <input type="text" id="search-input" placeholder="Search for text or use an advanced query..." />
    </div>

    <div class="info-box">
      <p><b>Query Guide:</b></p>
      <ul>
        <li><b>Simple Search:</b> Type any text to search across all fields (e.g., <code>approachs70</code>).</li>
        <li>
          <b>Advanced Query:</b> Use the format <code>Attribute Operator Value</code> (e.g., <code>WatchAppMemory >= 262144</code> or <code>APILevel > 3</code>). Supported operators are
          <code>>=</code>, <code><=</code>, <code>></code>, <code><</code>, <code>==</code>, <code>!=</code>.
        </li>
        <li><b>Sorting:</b> Click on any column header to sort the table.</li>
      </ul>
    </div>

    <div id="query-status" class="status" style="display: none"></div>

    <div class="table-container">
      <table id="results-table">
        <thead>
          <tr id="table-headers">
            <!-- Headers will be dynamically generated by JavaScript -->
          </tr>
        </thead>
        <tbody id="table-body">
          <!-- Data rows will be dynamically generated here -->
        </tbody>
      </table>
    </div>
    <div id="initial-status" class="status">Loading data...</div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- CONFIGURATION ---
        const JSON_URL = "garmin_devices.json";
        const COLUMNS = [
          "Active",
          "Name",
          "Id",
          "ScreenShape",
          "ScreenSize",
          "APILevel",
          "AudioContentProviderMemory",
          "BackgroundMemory",
          "DataFieldMemory",
          "GlanceMemory",
          "WatchAppMemory",
          "WatchFaceMemory",
          "WidgetMemory",
          "Touch",
          "Buttons",
        ];

        // --- DOM ELEMENTS ---
        const searchInput = document.getElementById("search-input");
        const tableHeaders = document.getElementById("table-headers");
        const tableBody = document.getElementById("table-body");
        const lastUpdatedSpan = document.getElementById("last-updated");
        const initialStatus = document.getElementById("initial-status");
        const queryStatus = document.getElementById("query-status");

        let allData = [];

        // --- INITIALIZATION ---
        function initialize() {
          renderTableHeaders();
          fetchData();
        }

        function renderTableHeaders() {
          tableHeaders.innerHTML = ""; // Clear existing headers
          COLUMNS.forEach((col, index) => {
            const th = document.createElement("th");
            th.textContent = col;
            th.className = "sortable"; // Add class to make it look clickable
            th.dataset.columnIndex = index; // Store column index
            th.addEventListener("click", () => sortTableByColumn(th));
            tableHeaders.appendChild(th);
          });
        }

        function fetchData() {
          fetch(JSON_URL)
            .then((response) => {
              if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
              const lastModified = response.headers.get("last-modified");
              if (lastModified) lastUpdatedSpan.textContent = new Date(lastModified).toUTCString();
              return response.json();
            })
            .then((data) => {
              allData = Array.isArray(data) ? data : [];
              initialStatus.style.display = "none";
              renderTableRows(allData);
            })
            .catch((error) => {
              console.error("Error fetching data:", error);
              initialStatus.innerHTML = `<p class="error">Could not load data. Please check the console for details.</p>`;
            });
        }

        // --- EVENT HANDLING ---
        searchInput.addEventListener("input", () => {
          const query = searchInput.value.trim();
          filterAndRender(query);
        });

        // --- CORE LOGIC ---
        function filterAndRender(query) {
          let filteredData = [];
          // Regex to parse "Attribute Operator Value" queries, e.g., "Memory >= 256000"
          const advancedQueryRegex = /^(\w+)\s*([><!=]=?)\s*"?\s*([-_\d\w\s\.]+)?\s*"?\s*$/;
          const match = query.match(advancedQueryRegex);

          try {
            if (match) {
              // Advanced JQ-like query
              const [, attribute, operator, value] = match;

              filteredData = allData.filter((item) => {
                const itemValue = item[attribute];
                if (itemValue === undefined) return false;
                var parsedValue = value;
                if (typeof itemValue === "number") {
                  parsedValue = parseFloat(value);
                  if (isNaN(value)) {
                    return false;
                  }
                } else if (typeof itemValue === "boolean") {
                  parsedValue = ["true", "1"].includes(value.toLowerCase());
                }

                switch (operator) {
                  case ">":
                    return itemValue > parsedValue;
                  case ">=":
                    return itemValue >= parsedValue;
                  case "<":
                    return itemValue < parsedValue;
                  case "<=":
                    return itemValue <= parsedValue;
                  case "=":
                  case "==":
                    return itemValue == parsedValue;
                  case "!=":
                    return itemValue != parsedValue;
                  default:
                    return false;
                }
              });
            } else if (query) {
              // Simple text search
              const lowerCaseQuery = query.toLowerCase();
              filteredData = allData.filter((item) => {
                return Object.values(item).some((val) => String(val).toLowerCase().includes(lowerCaseQuery));
              });
            } else {
              // No query, show all data
              filteredData = allData;
            }
            queryStatus.style.display = "none";
            renderTableRows(filteredData);
          } catch (e) {
            queryStatus.textContent = `Error: ${e.message}`;
            queryStatus.style.display = "block";
            renderTableRows([]); // Clear table on error
          }
        }

        function renderTableRows(data) {
          tableBody.innerHTML = "";

          if (data.length === 0 && searchInput.value) {
            const row = tableBody.insertRow();
            const cell = row.insertCell();
            cell.colSpan = COLUMNS.length;
            cell.className = "status";
            cell.textContent = "No results found for your query.";
          } else if (data.length === 0) {
            const row = tableBody.insertRow();
            const cell = row.insertCell();
            cell.colSpan = COLUMNS.length;
            cell.className = "status";
            cell.textContent = "No data available.";
          } else {
            data.forEach((item) => {
              const row = tableBody.insertRow();
              COLUMNS.forEach((col) => {
                const cell = row.insertCell();
                if (col == "Touch" || col == "Active") {
                  cell.textContent = item[col] ? "Yes" : "No";
                } else {
                  cell.textContent = item[col] ?? ""
                }
              });
            });
          }
        }

        // --- SORTING FUNCTION ---
        function sortTableByColumn(headerElement) {
          const columnIndex = parseInt(headerElement.dataset.columnIndex, 10);
          const currentDirection = headerElement.dataset.sortDirection || "desc";
          const newDirection = currentDirection === "desc" ? "asc" : "desc";
          headerElement.dataset.sortDirection = newDirection;

          // Remove sorting indicators from other columns
          tableHeaders.querySelectorAll("th").forEach((th) => {
            th.classList.remove("sort-asc", "sort-desc");
          });

          // Add sorting indicator to the current column
          headerElement.classList.add(newDirection === "asc" ? "sort-asc" : "sort-desc");

          // Get all rows from the current view (tbody) and sort them
          const rows = Array.from(tableBody.querySelectorAll("tr"));

          rows.sort((rowA, rowB) => {
            const valA = rowA.cells[columnIndex].textContent;
            const valB = rowB.cells[columnIndex].textContent;

            let comparison = 0;
            // Use localeCompare for proper string sorting
            comparison = valA.localeCompare(valB, undefined, { sensitivity: "base" });

            // Reverse the comparison if descending
            return newDirection === "asc" ? comparison : -comparison;
          });

          // Re-append the sorted rows to the table body
          tableBody.innerHTML = "";
          rows.forEach((row) => tableBody.appendChild(row));
        }

        initialize();
      });
    </script>
  </body>
</html>
